#include <bits/stdc++.h>
#define rep(i,nn,n) for (int i = nn; i < (n); ++i)
using namespace std;
using ll = long long;
using P = pair<int,int>;
#define chmin(x,y) x = min(x,y)
#define chmax(x,y) x = max(x,y)

/*
                       1
                  /         \
                2             3
               /  \         /    \
              4    5       6     7 
            /  \   / \    / \     / \
           8    9 10  11 12  13  14 15 
の木構造を構築する
*/

int main() {
    // 枝が存在する頂点間を列挙
    P root[16] ={{1,2},{1,3},{2,4},{2,5},{3,6},{3,7},{4,8},{4,9},{5,10},{5,11},{6,12},{6,13},{7,14},{7,15}};

    // 隣接リスト表現で木を構築
    vector<int> tree_list[16];

    // 隣接行列表現で木を構築
    int tree_matrix[16][16];
    for(int i=0;i<16;i++){
        for (int j = 0; j< 16;j++){
            tree_matrix[i][j] = 0;
        }
    }
    for(int i=0;i<16;i++){
        // 無向グラフ
        tree_list[root[i].first].push_back(root[i].second);
        tree_list[root[i].second].push_back(root[i].first);
        tree_matrix[root[i].first][root[i].second] = 1;
        tree_matrix[root[i].second][root[i].first] = 1;

        /*
        隣接リスト表現:                       隣接行列表現:
        1: 2 3                              1: 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0
        2: 1 4 5                            2: 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0
        3: 1 6 7                            3: 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0
        4: 2 8 9                            4: 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0
        5: 2 10 11                          5: 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0
        6: 3 12 13                          6: 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0
        7: 3 14 15                          7: 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1
        8: 4                                8: 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0
        9: 4                                9: 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0
        10: 5                               10: 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
        11: 5                               11: 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
        12: 6                               12: 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0
        13: 6                               13: 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0
        14: 7                               14: 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0
        15: 7                               15: 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0
        */
        
        // 有向グラフ
        // tree_list[root[i].first].push_back(root[i].second);
        // tree_matrix[root[i].first][root[i].second] = 1;
        /*
        隣接リスト表現:                       隣接行列表現:
        1: 2 3                              1: 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0
        2: 4 5                              2: 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0
        3: 6 7                              3: 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0
        4: 8 9                              4: 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0
        5: 10 11                            5: 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0
        6: 12 13                            6: 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 0
        7: 14 15                            7: 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 1
        8:                                  8: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
        9:                                  9: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
        10:                                 10: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
        11:                                 11: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
        12:                                 12: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
        13:                                 13: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
        14:                                 14: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
        15:                                 15: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
        */
    }
    return 0;
}